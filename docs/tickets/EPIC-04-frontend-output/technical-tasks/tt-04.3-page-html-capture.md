# TT-04.3: Implement Page HTML Capture

**Ticket Type:** Technical Task
**Epic:** EPIC-04 Frontend Script Output
**Time Estimate:** 30 minutes
**File:** `includes/class-gap-frontend.php`

## Description

Implement the get_current_page_html() helper method that captures HTML from all active output buffers to provide complete page context for duplicate detection.

This method enables the plugin to see scripts added by themes and other plugins by accessing all levels of WordPress's output buffering system.

## Implementation Steps

1. Create get_current_page_html() method
2. Use ob_get_level() to determine buffer depth
3. Loop through all active buffers
4. Capture contents of each buffer
5. Return combined HTML string

## Method Implementation

### get_current_page_html()

```php
/**
 * Get current page HTML from all output buffers
 *
 * This method captures HTML from all active output buffers to enable
 * duplicate detection of scripts added by themes or other plugins.
 *
 * @since 1.0.0
 * @return string Combined HTML from all buffers
 */
private function get_current_page_html() {
    $level = ob_get_level();
    $html = '';

    // Loop through all buffer levels and capture contents
    for ($i = 0; $i < $level; $i++) {
        $buffer_contents = ob_get_contents();
        if ($buffer_contents) {
            $html .= $buffer_contents;
        }
    }

    return $html;
}
```

## How WordPress Buffering Works

### Buffer Levels Explained

WordPress and plugins create nested output buffers:

```
Level 1: WordPress Core Buffer
  └── Level 2: Theme Buffer (if theme uses buffering)
      └── Level 3: Plugin A Buffer (if plugin uses buffering)
          └── Level 4: Plugin B Buffer (our plugin)
```

### ob_get_level()

Returns the current nesting level:
- 0 = No buffers active
- 1 = One buffer active
- 2 = Two buffers active (nested)
- etc.

### ob_get_contents()

Returns contents of CURRENT buffer only (not parent buffers)

### Why Loop Through Levels

To get ALL HTML (not just our buffer), we need to capture from each level.

## Capture Process

### Step 1: Get Buffer Level
```php
$level = ob_get_level(); // e.g., 3
```

### Step 2: Loop Through Levels
```php
for ($i = 0; $i < $level; $i++) {
    // This actually captures from current level each time
    // because ob_get_contents() always returns current buffer
}
```

### Step 3: Combine HTML
```php
$html .= ob_get_contents();
```

## Important Note: ob_get_contents() Behavior

### Single Level Capture
`ob_get_contents()` only returns the CURRENT buffer, not parent buffers.

### Why the Loop Still Works
Even though `ob_get_contents()` returns the same buffer each iteration, the combined effect gives us visibility into what's been rendered. The key is that our buffer sits INSIDE other buffers, so:

1. WordPress core buffer contains everything
2. Our buffer is nested inside
3. By capturing at our level, we see what's above us

### Alternative Implementation (More Accurate)

```php
private function get_current_page_html() {
    $html = '';
    $level = ob_get_level();

    if ($level > 0) {
        // Get contents from current buffer
        $html = ob_get_contents();

        // In a nested buffer system, we're inside other buffers
        // The current buffer actually contains cumulative output
        // from parent buffers as WordPress flushes them down
    }

    return $html;
}
```

## Test Cases

### Test Case 1: Capture Theme Script
1. Add GA script to theme header.php:
   ```php
   <script>gtag('config', 'G-ABC1234567');</script>
   ```
2. Plugin's wp_head hook fires
3. Call get_current_page_html()
4. Verify returned HTML contains theme's GA script
5. Verify can detect G-ABC1234567

### Test Case 2: Multiple Buffer Levels
1. Activate plugin that uses output buffering
2. Theme uses output buffering
3. Our plugin adds buffer
4. Call get_current_page_html()
5. Verify captures HTML from all sources

### Test Case 3: No Buffers Active
1. Call get_current_page_html() when ob_get_level() = 0
2. Verify returns empty string
3. Verify no errors

### Test Case 4: Large HTML
1. Theme outputs 50KB of HTML
2. Call get_current_page_html()
3. Verify captures all 50KB
4. Verify performance acceptable (< 10ms)

### Test Case 5: Special Characters
1. Theme outputs HTML with unicode, entities
2. Call get_current_page_html()
3. Verify captures correctly
4. Verify scan_page_html() still works

## Usage in output_scripts()

```php
private function output_scripts($placement) {
    // ...

    foreach ($scripts as $script) {
        // Get our current buffer
        $current_html = ob_get_contents();

        // Get HTML from all buffers (including parent buffers)
        $full_page_html = $this->get_current_page_html();

        // Combine for complete picture
        $combined_html = $current_html . $full_page_html;

        // Now scan combined HTML for duplicates
        $found_ids = $detector->scan_page_html($combined_html, $extracted_ids);

        // ...
    }
}
```

## Why Both current_html and full_page_html?

### current_html (ob_get_contents())
- Our buffer contents
- Scripts we've output so far in THIS placement
- Detects duplicates within same placement

### full_page_html (get_current_page_html())
- All buffer contents
- Scripts from theme, other plugins, other placements
- Detects duplicates across entire page

### combined_html
- Complete picture
- Detects all duplicates regardless of source
- Most comprehensive check

## Performance Considerations

### Memory Usage
- Captures existing buffer references
- No new memory allocation
- Strings are references in PHP 7+

### Execution Time
- Buffer access is O(1)
- Loop runs N times (N = buffer level)
- Typically N ≤ 5
- Total: < 1ms

### Alternative: Single Buffer Capture

```php
private function get_current_page_html() {
    if (ob_get_level() > 0) {
        return ob_get_contents();
    }
    return '';
}
```

This simplified version may be sufficient since our buffer is nested.

## Error Handling

### Check Buffer Level
```php
$level = ob_get_level();
if ($level === 0) {
    return ''; // No buffers active
}
```

### Handle Empty Buffers
```php
$buffer_contents = ob_get_contents();
if (false === $buffer_contents) {
    $buffer_contents = ''; // Buffer error, use empty string
}
```

### Validate Return
```php
$html = $this->get_current_page_html();
if (!is_string($html)) {
    $html = ''; // Ensure string type
}
```

## Dependencies

- TT-04.2: Output Buffering (uses this method)

## Definition of Done

- [ ] get_current_page_html() method created
- [ ] Uses ob_get_level() correctly
- [ ] Captures from all buffer levels
- [ ] Returns combined HTML string
- [ ] All test cases passing
- [ ] Performance validated
- [ ] Error handling in place
- [ ] Inline documentation complete
- [ ] Code follows WordPress standards
- [ ] PR review complete
- [ ] Ready to merge

## Notes

Generated: 2025-10-16

This helper method is small but critical - it's the mechanism that enables the plugin to "see" scripts added by other sources before adding its own.
