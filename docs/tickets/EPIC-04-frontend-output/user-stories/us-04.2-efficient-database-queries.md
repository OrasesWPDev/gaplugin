# US-04.2: Efficient Database Queries for Script Retrieval

**Ticket Type:** User Story
**Epic:** EPIC-04 Frontend Script Output
**Story Points:** 5
**Time Estimate:** 170 minutes

## Description

As a developer, I need efficient database queries for script retrieval so that the plugin has minimal performance impact on page load times while fetching tracking scripts.

This implements smart querying with meta_query filtering and request-level caching to ensure the plugin retrieves scripts efficiently without causing N+1 query problems or unnecessary database overhead.

## Acceptance Criteria

- [ ] Single query retrieves scripts by placement and active status
- [ ] Results cached at request level (no duplicate queries)
- [ ] Query uses meta_query for efficient filtering
- [ ] Scope filtering happens in PHP (not SQL)
- [ ] Maximum 1 query per placement location

## Implementation Tasks

- [ ] Implement get_active_scripts() method (75 min)
- [ ] Add request-level caching with $scripts_cache property (20 min)
- [ ] Build meta_query for placement and active status (25 min)
- [ ] Implement scope filtering logic (30 min)
- [ ] Test query efficiency (20 min)

## Technical Details

### Query Structure

```php
$args = array(
    'post_type'      => 'tracking_script',
    'post_status'    => 'publish',
    'posts_per_page' => -1,
    'meta_query'     => array(
        'relation' => 'AND',
        array(
            'key'     => '_gap_placement',
            'value'   => $placement,
            'compare' => '='
        ),
        array(
            'key'     => '_gap_is_active',
            'value'   => '1',
            'compare' => '='
        )
    ),
    'orderby'        => 'menu_order title',
    'order'          => 'ASC'
);

$scripts = get_posts($args);
```

### Request-Level Caching

```php
private $scripts_cache = array();

private function get_active_scripts($placement) {
    // Check cache first
    $cache_key = $placement;
    if (isset($this->scripts_cache[$cache_key])) {
        return $this->scripts_cache[$cache_key];
    }

    // Query database
    $scripts = get_posts($args);

    // Filter by scope (in PHP)
    $filtered_scripts = $this->filter_by_scope($scripts);

    // Cache results
    $this->scripts_cache[$cache_key] = $filtered_scripts;

    return $filtered_scripts;
}
```

### Scope Filtering (PHP-based)

```php
private function filter_by_scope($scripts) {
    $current_page_id = get_the_ID();
    $filtered_scripts = array();

    foreach ($scripts as $script) {
        $scope = get_post_meta($script->ID, '_gap_scope', true);

        if ('global' === $scope) {
            // Global scripts always included
            $filtered_scripts[] = $script;
        } elseif ('specific_pages' === $scope && $current_page_id) {
            $target_pages = get_post_meta($script->ID, '_gap_target_pages', true);
            if (is_array($target_pages) && in_array($current_page_id, $target_pages, true)) {
                $filtered_scripts[] = $script;
            }
        }
    }

    return $filtered_scripts;
}
```

## Performance Optimization

### Meta Query Benefits
- Single database query
- WordPress handles JOIN operations
- Indexed meta keys for fast lookup
- No additional queries needed

### Request-Level Caching
- Prevents duplicate queries
- Cached per placement location
- Cleared automatically at request end
- No persistent caching needed

### Query Efficiency
- Returns only published posts
- Filters by active status in SQL
- Orders results efficiently
- No post-query filtering except scope

## Test Cases

### Test Case 1: Single Query Per Placement
1. Enable Query Monitor plugin
2. Create 3 scripts: head, body_bottom, footer
3. Load frontend page
4. Check Query Monitor
5. Verify exactly 3 queries (one per placement)
6. Verify no duplicate queries

### Test Case 2: Caching Works
1. Create script with head placement
2. Add debug logging to get_active_scripts()
3. Load frontend page
4. Verify get_active_scripts('head') called multiple times
5. Verify only 1 database query executed
6. Verify subsequent calls use cache

### Test Case 3: Query Filters Correctly
1. Create 2 head scripts: one active, one inactive
2. Load frontend page
3. Verify only active script output
4. Check Query Monitor
5. Verify inactive script not retrieved from database

### Test Case 4: Placement Filter Works
1. Create scripts: 2 head, 2 body_bottom, 2 footer
2. All active and global
3. Load frontend page
4. Verify each placement query returns only its scripts
5. Verify no script appears in wrong placement

### Test Case 5: Order Maintained
1. Create 3 head scripts
2. Set menu_order: Script A (10), Script B (5), Script C (15)
3. Load frontend page
4. View page source
5. Verify order: B, A, C (ascending menu_order)

## Database Query Analysis

### Expected Query Count
- **Homepage:** 4 queries max (one per placement)
- **Single Page:** 4 queries max (same as homepage)
- **With Caching:** Actually 3-4 queries total (footer placement may have no scripts)

### Query Performance
- **Index Usage:** Meta keys should be indexed
- **Query Time:** < 5ms per query
- **Total Impact:** < 20ms for all queries

## Monitoring Tools

### Query Monitor Plugin
Shows:
- Total query count
- Query execution time
- Duplicate queries
- Slow queries

### P3 Plugin Profiler
Shows:
- Plugin performance impact
- Query breakdown
- Load time contribution

### Debug Bar
Shows:
- Query details
- Execution order
- Cache hits/misses

## Dependencies

- EPIC-01: Foundation
- EPIC-02: Admin Interface (meta fields must exist)

## Definition of Done

- [ ] get_active_scripts() method implemented
- [ ] Request-level caching working
- [ ] Meta query properly structured
- [ ] Scope filtering functional
- [ ] Query count â‰¤ 1 per placement
- [ ] All test cases passing
- [ ] Query Monitor validation complete
- [ ] Performance benchmarks met
- [ ] Code follows WordPress standards
- [ ] PR review complete
- [ ] Ready to merge

## Notes

Generated: 2025-10-16

Efficient querying is critical for performance. The combination of meta_query and request-level caching ensures minimal database overhead regardless of how many scripts exist.
