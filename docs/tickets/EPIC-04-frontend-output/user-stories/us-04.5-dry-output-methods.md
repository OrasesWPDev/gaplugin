# US-04.5: Reusable Output Methods Following DRY

**Ticket Type:** User Story
**Epic:** EPIC-04 Frontend Script Output
**Story Points:** 3
**Time Estimate:** 100 minutes

## Description

As a developer, I need reusable output methods following DRY principles so that the codebase is maintainable, testable, and doesn't duplicate logic across multiple placement-specific methods.

This implements a single unified output method that handles all placements, with lightweight wrapper methods for each WordPress hook, eliminating code duplication and simplifying maintenance.

## Acceptance Criteria

- [ ] Single output_scripts() method handles all placements
- [ ] Placement-specific methods call output_scripts()
- [ ] No duplicate query logic
- [ ] No duplicate output logic
- [ ] Code is maintainable and testable

## Implementation Tasks

- [ ] Create output_scripts($placement) method (60 min)
- [ ] Create output_head_scripts() wrapper (5 min)
- [ ] Create output_body_top_scripts() wrapper (5 min)
- [ ] Create output_body_bottom_scripts() wrapper (5 min)
- [ ] Create output_footer_scripts() wrapper (5 min)
- [ ] Test all placements (20 min)

## Technical Details

### DRY Implementation

```php
/**
 * Output scripts for a specific placement
 *
 * @since 1.0.0
 * @param string $placement The placement location (head, body_top, body_bottom, footer)
 * @return void
 */
private function output_scripts($placement) {
    $scripts = $this->get_active_scripts($placement);

    if (empty($scripts)) {
        return;
    }

    echo "\n<!-- GA Plugin: " . esc_html($placement) . " -->\n";

    ob_start();

    foreach ($scripts as $script) {
        $content = get_post_meta($script->ID, '_gap_script_content', true);
        $extracted_ids = get_post_meta($script->ID, '_gap_extracted_ids', true);

        if (!empty($extracted_ids) && is_array($extracted_ids)) {
            // Duplicate detection logic
            $current_html = ob_get_contents();
            $full_page_html = $this->get_current_page_html();
            $combined_html = $current_html . $full_page_html;

            $detector = GAP_Conflict_Detector::get_instance();
            $found_ids = $detector->scan_page_html($combined_html, $extracted_ids);

            if (!empty($found_ids)) {
                // Skip duplicate
                $found_id_list = implode(', ', array_column($found_ids, 'id'));

                echo "<!-- GA Plugin: Duplicate tracking script detected for \"" . esc_html(get_the_title($script->ID)) . "\". ";
                echo "IDs already on page: " . esc_html($found_id_list) . ". ";
                echo "Skipping output to prevent double-tracking. -->\n";

                $message = sprintf(
                    'Duplicate tracking script detected for "%s". IDs already on page: %s. Skipping output to prevent double-tracking.',
                    get_the_title($script->ID),
                    $found_id_list
                );
                $detector->log_conflict($message);

                continue;
            }
        }

        // No duplicates - output script
        echo $content . "\n";
    }

    ob_end_flush();

    echo "<!-- /GA Plugin: " . esc_html($placement) . " -->\n\n";
}

/**
 * Output scripts in head
 *
 * @since 1.0.0
 * @return void
 */
public function output_head_scripts() {
    $this->output_scripts('head');
}

/**
 * Output scripts in body top
 *
 * @since 1.0.0
 * @return void
 */
public function output_body_top_scripts() {
    $this->output_scripts('body_top');
}

/**
 * Output scripts in body bottom
 *
 * @since 1.0.0
 * @return void
 */
public function output_body_bottom_scripts() {
    $this->output_scripts('body_bottom');
}

/**
 * Output scripts in footer
 *
 * @since 1.0.0
 * @return void
 */
public function output_footer_scripts() {
    $this->output_scripts('footer');
}
```

## DRY Benefits

### Before (WET - Write Everything Twice)
```php
public function output_head_scripts() {
    $args = array(/* ... */);
    $scripts = get_posts($args);
    foreach ($scripts as $script) {
        // Duplicate detection logic
        // Output logic
    }
}

public function output_body_top_scripts() {
    $args = array(/* ... */);
    $scripts = get_posts($args);
    foreach ($scripts as $script) {
        // Same duplicate detection logic (duplicated!)
        // Same output logic (duplicated!)
    }
}

// Repeat for body_bottom and footer...
```

**Problems:**
- Logic duplicated 4 times
- Bug fixes need 4 changes
- Testing needs 4 scenarios
- Hard to maintain

### After (DRY - Don't Repeat Yourself)
```php
private function output_scripts($placement) {
    // All logic in one place
}

public function output_head_scripts() {
    $this->output_scripts('head');
}

public function output_body_top_scripts() {
    $this->output_scripts('body_top');
}

// etc.
```

**Benefits:**
- Logic in one place
- Bug fixes in one spot
- Testing in one method
- Easy to maintain

## Wrapper Methods

### Purpose
- Provide WordPress hook callbacks
- Pass placement parameter
- Keep public API clean

### Pattern
```php
public function output_{placement}_scripts() {
    $this->output_scripts('{placement}');
}
```

### Examples
- `output_head_scripts()` → `output_scripts('head')`
- `output_body_top_scripts()` → `output_scripts('body_top')`
- `output_body_bottom_scripts()` → `output_scripts('body_bottom')`
- `output_footer_scripts()` → `output_scripts('footer')`

## Hook Registration

```php
private function __construct() {
    add_action('wp_head', array($this, 'output_head_scripts'), 1);
    add_action('wp_body_open', array($this, 'output_body_top_scripts'), 1);
    add_action('wp_footer', array($this, 'output_body_bottom_scripts'), 1);
    add_action('wp_footer', array($this, 'output_footer_scripts'), 999);
}
```

## Test Cases

### Test Case 1: Head Scripts
1. Create script with head placement
2. Set to active and global
3. Load page
4. Verify output_head_scripts() called
5. Verify output_scripts('head') called
6. Verify script appears in head

### Test Case 2: Body Top Scripts
1. Create script with body_top placement
2. Set to active and global
3. Load page
4. Verify output_body_top_scripts() called
5. Verify output_scripts('body_top') called
6. Verify script appears after body tag

### Test Case 3: Body Bottom Scripts
1. Create script with body_bottom placement
2. Set to active and global
3. Load page
4. Verify output_body_bottom_scripts() called
5. Verify output_scripts('body_bottom') called
6. Verify script appears before /body

### Test Case 4: Footer Scripts
1. Create script with footer placement
2. Set to active and global
3. Load page
4. Verify output_footer_scripts() called
5. Verify output_scripts('footer') called
6. Verify script appears at end

### Test Case 5: All Placements Together
1. Create 4 scripts (one per placement)
2. All active and global
3. Load page
4. Verify all 4 wrapper methods called
5. Verify output_scripts() called 4 times (once per placement)
6. Verify all scripts output correctly

### Test Case 6: Empty Placement
1. No scripts created for head placement
2. Load page
3. Verify output_head_scripts() called
4. Verify output_scripts('head') called
5. Verify returns early (no output)
6. Verify no HTML comments for empty placement

## Code Quality Benefits

### Maintainability
- Single source of truth
- Changes in one place
- Easy to understand
- Reduced complexity

### Testability
- Test one method thoroughly
- Wrappers are trivial
- Easy to mock/stub
- Clear expectations

### Readability
- Clear separation of concerns
- Wrapper methods self-documenting
- Core logic centralized
- Easier for new developers

## Dependencies

- US-04.2: Efficient Database Queries (get_active_scripts)
- US-04.4: Duplicate Prevention (uses duplicate detection logic)

## Definition of Done

- [ ] output_scripts() method implemented
- [ ] All wrapper methods created
- [ ] No code duplication
- [ ] All hooks registered correctly
- [ ] All test cases passing
- [ ] Code follows DRY principles
- [ ] Code follows WordPress standards
- [ ] Inline documentation complete
- [ ] PR review complete
- [ ] Ready to merge

## Notes

Generated: 2025-10-16

DRY is fundamental to maintainable code. This architecture makes the plugin easier to test, debug, and extend in the future.
